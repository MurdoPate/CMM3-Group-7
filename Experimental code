# ============================
# Full pipeline: data + model  (3.2 km/h, Coarse→Fine δ sweep)
# ============================

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp, trapezoid
from scipy.interpolate import make_interp_spline
import kagglehub

plt.ion()

# ----------------------------------------
# 1) Load gait dataset (Kaggle)
# ----------------------------------------
print("→ Downloading gait dataset...")
path = kagglehub.dataset_download("anitarostami/enhanced-gait-biomechanics-dataset")
csv = next((os.path.join(path, f) for f in os.listdir(path) if f.endswith(".csv")), None)
if not csv:
    raise FileNotFoundError("No CSV found in dataset path.")

df = pd.read_csv(csv)
data = df[(df["joint"] == 2) & (df["condition"] == 1)].copy()

def leg_stats(d, var):
    g = d.groupby(["time", "leg"])[var].agg(["mean", "std"]).reset_index()
    left  = g[g["leg"] == 1].sort_values("time")
    right = g[g["leg"] == 2].sort_values("time")
    return left, right

angle_L, _ = leg_stats(data, "angle")
print("✓ Dataset loaded and filtered (knee, unbraced)")

# ----------------------------------------
# 2) Reference gait from dataset (phase 0..1)
# ----------------------------------------
phi_ref_raw   = angle_L["time"].to_numpy(dtype=float)
theta_ref_raw = angle_L["mean"].to_numpy(dtype=float)

phi_ref, keep_idx = np.unique(phi_ref_raw, return_index=True)
theta_ref_exp = theta_ref_raw[keep_idx]

def theta_ref(phi):
    return np.interp(np.mod(phi, 1.0), phi_ref, theta_ref_exp)

dtheta_dphi_samples = np.gradient(theta_ref_exp, phi_ref)
def dtheta_dphi(phi):
    return np.interp(np.mod(phi, 1.0), phi_ref, dtheta_dphi_samples)

exp_time_pct  = phi_ref * 100.0
exp_angle_deg = np.rad2deg(theta_ref_exp)
theta0_mean = float(np.mean(theta_ref(phi_ref)))

# ----------------------------------------
# 3) Geometry from height + inertia
# ----------------------------------------
try:
    height = float(input("Enter your height in cm: ").strip() or "178")
except ValueError:
    height = 178.0
print(f"Using height = {height:.1f} cm")

m = 4.0
g = 9.81

lower_leg_length = (height - 123) / 1.24
foot_size        = (0.044 * height) + 19.286
stride_length_cm = 0.415 * height
stride_length_m  = stride_length_cm / 100.0

L1 = lower_leg_length / 100.0
L2 = foot_size / 100.0

den   = 2 * (lower_leg_length + foot_size)
x_bar = (foot_size**2) / den
y_bar = (lower_leg_length**2) / den
COM_to_A = lower_leg_length - y_bar
L3 = COM_to_A / 100.0

I_A = (
    m * (1.0 / (lower_leg_length + foot_size)) *
    ((1/3)*lower_leg_length**3 + lower_leg_length**2*foot_size + (1/3)*foot_size**3)
) / 1e4

print("\n--- Geometry ---")
print(f"L1={lower_leg_length:.2f} cm  L2={foot_size:.2f} cm  L3={COM_to_A:.2f} cm ({L3:.3f} m)")
print(f"I_A={I_A:.6f} kg·m²")

# ----------------------------------------
# 4) Target speed and stiffness
# ----------------------------------------
walking_speed = 0.888889  # m/s (≈3.2 km/h)
f_target = walking_speed / stride_length_m
T_cycle  = 1.0 / f_target
w_target = 2*np.pi*f_target

print(f"\n--- Target gait ---\nStride={stride_length_m:.3f} m  v={walking_speed:.3f} m/s  f={f_target:.3f} Hz")

k_star = (I_A * w_target**2) - (m * g * L3)
print(f"\nCalculated stiffness from height & cadence (k*): {k_star:.3f} N·m/rad")

# Soft passive stiffness
k_soft = 5.0
print(f"Using soft stiffness for prosthetic joint: k_soft = {k_soft:.2f} N·m/rad")

# ----------------------------------------
# 5) Dynamics + simulators
# ----------------------------------------
def knee_rhs(t, y, p):
    theta, theta_dot = y
    k, c, f, theta0, Kp, Kd, m_, g_, L3_, I_ = (
        p["k"], p["c"], p["f"], p["theta0"], p["Kp"], p["Kd"], p["m"], p["g"], p["L3"], p["I"]
    )
    tau_joint = -k*(theta - theta0) - c*theta_dot
    tau_g     = m_ * g_ * L3_ * np.sin(theta)
    phi = (f*t) % 1.0
    th_des     = theta_ref(phi)
    th_des_dot = dtheta_dphi(phi) * f
    tau_hip = Kp*(th_des - theta) + Kd*(th_des_dot - theta_dot)
    theta_ddot = (tau_hip - tau_g + tau_joint) / I_
    return [theta_dot, theta_ddot]

def simulate_cycles(k, c, f, Kp=200.0, Kd=15.0, theta0=theta0_mean, ncycles=5, n=2000):
    T = 1.0 / f
    p = dict(k=k, c=c, f=f, Kp=Kp, Kd=Kd, theta0=theta0, m=m, g=g, L3=L3, I=I_A)
    y0 = [theta_ref(0.0), dtheta_dphi(0.0) * f]
    sol = solve_ivp(lambda t, y: knee_rhs(t, y, p),
                    [0.0, ncycles*T], y0, method="RK45",
                    rtol=1e-7, atol=1e-9, max_step=T/800)
    t_last = np.linspace((ncycles-1)*T, ncycles*T, n, endpoint=False)
    theta_last  = np.interp(t_last, sol.t, sol.y[0])
    thetad_last = np.interp(t_last, sol.t, sol.y[1])
    phi_t = (f*t_last) % 1.0
    theta_ref_t = theta_ref(phi_t)
    t_rel = t_last - (ncycles-1)*T
    return t_rel, theta_last, thetad_last, theta_ref_t

def energy_damped(theta_dot, c, t):
    return float(c * trapezoid(theta_dot**2, t))

# Smooth reference curve
t_s = np.linspace(0, 100, 300)
ang_s = make_interp_spline(exp_time_pct, exp_angle_deg, k=3)(t_s)

# ----------------------------------------
# 6) Coarse→Fine δ sweep
# ----------------------------------------
Kp, Kd = 200.0, 15.0

def rms_for_delta(dlt, ncycles=2, n=600):
    """Return (RMS_error_deg, c) for given δ."""
    c_i = 2.0 * dlt * np.sqrt(I_A * (k_soft + m*g*L3))
    t_tmp, th_tmp, _, th_ref_tmp = simulate_cycles(
        k_soft, c_i, f_target, Kp=Kp, Kd=Kd, theta0=theta0_mean, ncycles=ncycles, n=n
    )
    rms = np.rad2deg(np.sqrt(np.mean((th_tmp - th_ref_tmp)**2)))
    return rms, c_i

# Coarse sweep (25 δ values)
delta_coarse = np.linspace(0.1, 0.8, 25)
rms_coarse = np.zeros_like(delta_coarse)
for i, dlt in enumerate(delta_coarse):
    rms_coarse[i], _ = rms_for_delta(dlt)

best_idx = int(np.argmin(rms_coarse))
delta_best_coarse = float(delta_coarse[best_idx])

# Fine sweep (15 δ around coarse best)
lo = max(0.1, delta_best_coarse - 0.05)
hi = min(0.8, delta_best_coarse + 0.05)
delta_fine = np.linspace(lo, hi, 15)
rms_fine = np.zeros_like(delta_fine)
c_fine   = np.zeros_like(delta_fine)
for j, dlt in enumerate(delta_fine):
    rms_fine[j], c_fine[j] = rms_for_delta(dlt)

j_best = int(np.argmin(rms_fine))
best_delta = float(delta_fine[j_best])
best_c     = float(c_fine[j_best])
best_rms   = float(rms_fine[j_best])


print(f"\n--- δ sweep results ---")
print(f"Best δ = {best_delta:.4f} → c = {best_c:.4f} N·m·s/rad  (RMS ≈ {best_rms:.3f}°)")

# Plot RMS vs δ
plt.figure(figsize=(10,5))
plt.plot(delta_coarse, rms_coarse, 'o-', label="coarse")
plt.plot(delta_fine, rms_fine, 's-', label="fine")
plt.axvline(best_delta, color='r', ls='--', label=f"best δ={best_delta:.3f}")
plt.xlabel("Damping ratio δ"); plt.ylabel("RMS error [°]")
plt.title("RMS tracking error vs δ (coarse→fine sweep)")
plt.legend(); plt.grid(True, ls='--', alpha=0.6); plt.tight_layout(); plt.show()

# ----------------------------------------
# 7) Final high-res simulation at best δ
# ----------------------------------------
t, theta_sim, thetad_sim, theta_ref_last = simulate_cycles(
    k_soft, best_c, f_target, Kp=Kp, Kd=Kd, theta0=theta0_mean, ncycles=5, n=2000
)
gait_percent = (t / T_cycle) * 100.0
theta_sim_deg = np.rad2deg(theta_sim)
rms_final = np.rad2deg(np.sqrt(np.mean((theta_sim - theta_ref_last)**2)))
E_damp  = energy_damped(thetad_sim, best_c, t)

plt.figure(figsize=(10,6))
plt.plot(t_s, ang_s, 'k', lw=2, label='Experimental gait (≈3.2 km/h)')
plt.plot(gait_percent, theta_sim_deg, 'g--', lw=2,
         label=f'Soft passive + PD (k={k_soft}, δ={best_delta:.3f}, c={best_c:.3f})  RMS={rms_final:.2f}°')
plt.xlabel("Gait cycle (%)"); plt.ylabel("Knee angle (°)")
plt.title("Experimental vs Simulated Knee Angle (last cycle, best δ)")
plt.legend(); plt.grid(True, ls='--', alpha=0.6); plt.tight_layout(); plt.show()

print(f"\nEnergy dissipated by damping (best δ): {E_damp:.3f} J per step")